* For all the cases where we omit the computation and just say that 
  the value is equal to (or -1 *) the other computed value, prove that
  this is the case, and not something that can switch sign if the positions 
  differ





* Benchmark the current version of Nuclear Matrix computation
* Write a parallel implementation of the overlap matrix calculation
	- Regardless of whether its faster or slower, do the same thing for
      the other 2 matrix calculations
* Unit test the current version of the Nuclear matrix computation
	- How much does changing epsilon change the final result?
	- How much does changing epsilon change the computation speed?
* Adding profiling to profile the Nuclear matrix computation
	- Can it be sped up further?
	- Profile it in a single thread implementation first
* Implement the faster version that is in the C++ Hartree Fock program
	- Is it actually faster?




Basis Sets
	* Support the following basis sets:
		- STO-3G, STO-6G, 6-31G, 6-31G* [aka 6-31G(d)], 6-31G** [aka 6-31G(d,p)]
	* Support all atoms up to Calcium (20)


Unit Tests
	* Right now, unit tests are just set up to make sure we align with the other
		C++ Hartree-Fock program. Ideally, we should assemble as many unit tests
		as we can where the values actually come from the literature (and therefore,
		we should track those citations). 
			- In thinking about it, I feel like such a set of data might already exist,
			  but if not, then it probably should be created.